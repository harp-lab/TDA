<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Barcodes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"
            integrity="sha512-M7nHCiNUOwFt6Us3r8alutZLm9qMt4s9951uo8jqO4UwJ1hziseL6O3ndFyigx6+LREfZqnhHxYjKRJ8ZQ69DQ=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
<div id="barcodes"></div>
<script>

    function get_unique_distances(matrix) {
        const unique_distances = new Set();
        for (let i = 0; i < matrix.length; i++) {
            for (let j = i + 1; j < matrix.length; j++) {
                unique_distances.add(matrix[i][j]);
            }
        }
        const distances = Array.from(unique_distances);
        distances.sort();
        return distances;
    }

    function get_components(matrix, min_distance) {
        const components = [];
        const number_of_nodes = matrix.length;
        const seen = new Set();
        for (let i = 0; i < number_of_nodes; i++) {
            if (!seen.has(i)) {
                let component = [];
                let visited = new Array(number_of_nodes).fill(false);
                let queue = [i];
                visited[i] = true;
                while (queue.length !== 0) {
                    const current_node = queue.shift();
                    seen.add(current_node);
                    component.push(current_node);
                    for (let node = 0; node < number_of_nodes; node++) {
                        if (visited[node] === false && (matrix[current_node][node] <= min_distance)) {
                            queue.push(node);
                            visited[node] = true;
                        }
                    }
                }
                components.push(component);
            }
        }
        return components;
    }

    async function get_data() {
        let data_file = "../data/fmri_data/normalize_dfc_2500_subject_1_time_1.txt";
        // data_file = "../data/demo_data.txt";
        data_file = "../data/time_varying_4_4.csv";
        return d3.text(data_file).then(function (text) {
            let matrix;
            if (data_file.endsWith("csv")) {
                matrix = d3.csvParseRows(text, (row) => row.map((value) => +value));
            } else {
                matrix = d3.tsvParseRows(text, (row) => row.map((value) => +value));
            }
            return matrix;
        });
    }

    function get_0_dim_barcodes(matrix) {
        const number_of_nodes = matrix.length;
        let barcodes = [];
        const unique_distances = get_unique_distances(matrix);
        const max_distance = unique_distances[unique_distances.length - 1];
        let prev_number_of_components = -1;
        for (let i = 0; i < unique_distances.length; i++) {
            const distance = unique_distances[i];
            const components = get_components(matrix, distance);
            const number_of_components = components.length;
            if (number_of_components === 1) {
                barcodes.push([0, distance, components]);
                break;
            }
            if (prev_number_of_components === -1) {
                prev_number_of_components = number_of_components;
                barcodes.push([0, distance, components]);
                continue;
            }
            if (number_of_components < prev_number_of_components) {
                for (let i = 0; i < (prev_number_of_components - number_of_components); i++) {
                    barcodes.push([0, distance, components]);
                }
                prev_number_of_components = number_of_components;
            }
        }
        const remaining_bars = number_of_nodes - barcodes.length;
        const components = get_components(matrix, max_distance);
        for (let i = 0; i < remaining_bars; i++) {
            barcodes.push([0, max_distance, components]);
        }
        return barcodes;
    }

    function show_barcode(data) {

        // Declare the chart dimensions and margins.
        const width = 500;
        const marginTop = 20;
        const marginRight = 20;
        const marginBottom = 20;
        const marginLeft = 20;
        const barHeight = 10; // Fixed height for the bars
        // Calculate the height of the SVG container based on the number of bars
        const height = data.length * (barHeight + 5) + marginTop + marginBottom;
        const padding = 5;
        // Sort data by the second element of each sub-array (largest to smallest)
        data.sort((a, b) => b[1] - a[1]);
        // Calculate the maximum value in the data array
        const maxValue = d3.max(data, d => d[1]);

        // Create scales for x and y axes
        const xScale = d3.scaleLinear()
            .domain([0, maxValue])
            .range([marginLeft, width]);

        const yScale = d3.scaleBand()
            .domain(d3.range(data.length))
            .range([marginTop+padding, height - marginBottom])
            .padding(0.1);

        // Create the SVG container.
        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height);

        // Create horizontal bars
        svg.selectAll("rect")
            .data(data)
            .enter().append("rect")
            .attr("x", marginLeft)
            .attr("y", (d, i) => yScale(i))
            .attr("width", d => xScale(d[1]))
            .attr("height", barHeight)
            .attr("fill", "steelblue");

        // Add the x-axis.
        svg.append("g")
            .attr("transform", `translate(0,${marginTop})`)
            .call(d3.axisTop(xScale));

        // Select the container with id "barcodes"
        const container = d3.select("#barcodes");

        // Append the SVG element to the container
        container.node().append(svg.node());
    }

    get_data().then(function (matrix) {
        const data = get_0_dim_barcodes(matrix);
        show_barcode(data);
    });

</script>
</body>
</html>